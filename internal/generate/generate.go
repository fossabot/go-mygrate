package generate

import (
	"bytes"
	"fmt"
	"io/ioutil"
	"os"
	"path"
	"path/filepath"
	"sort"
	"text/template"
	"time"
)

type tplMygration struct {
	ID   int
	Name string
	Up   string
	Down string
}

type tplVarForMygrations struct {
	Time       time.Time
	Mygrations []*tplMygration
}

type tplVarForMygration struct {
	ID   int
	Name string
}

var templateMygrationsGo = template.Must(
	template.New("mygrations.go").Parse(`// Code generated by mygrate; DO NOT EDIT.
// {{ .Time }}

// Package mygrations provides the migration template, files and generate helper for the project
package mygrations

import (
	"github.com/demaggus83/go-mygrate/pkg/mygrate"
)

func Register(m *mygrate.Mygrate) {
{{- range .Mygrations}}
	m.Register({{ .ID }}, "{{ .Name }}", {{ .Up }}, {{ .Down }})
{{- end}}
}

`))

var templateMygrationFile = []byte(`package mygrations

import (
	"errors"
)

func Mygration_{{ .ID }}_{{ .Name }}_up(dep interface{}) error {
	return errors.New("need to implement")
}

func Mygration_{{ .ID }}_{{ .Name }}_down(dep interface{}) error {
	return errors.New("need to implement")
}

`)

var generateFile = []byte(`// Code generated by mygrate; DO NOT EDIT.

package main

import "github.com/demaggus83/go-mygrate/pkg/mygrate"

// this file should be used in your project with go generate
// example: //go:generate go run mygrations/generate/mygrations.go

func main() {
	err := mygrate.Generate()
	if err != nil {
		panic(err)
	}
}

`)

func createGenerateFile(mygrationsPath string) error {
	p := path.Join(mygrationsPath, "generate")
	err := ensureDir(p)
	if err != nil {
		return err
	}

	p = path.Join(p, "mygrations.go")

	if _, err := os.Stat(p); os.IsNotExist(err) {
		return ioutil.WriteFile(p, generateFile, 0644)
	}

	return nil
}

func createTplFile(mygrationsPath string) error {
	p := path.Join(mygrationsPath, "mygration.tpl")

	if _, err := os.Stat(p); os.IsNotExist(err) {
		return ioutil.WriteFile(p, templateMygrationFile, 0644)
	}

	return nil
}

// Init will create the mygrationsPath.
func Init(mygrationsPath string) error {
	err := ensureDir(mygrationsPath)
	if err != nil {
		return err
	}

	err = createTplFile(mygrationsPath)
	if err != nil {
		return err
	}

	err = createGenerateFile(mygrationsPath)
	if err != nil {
		return err
	}

	return nil
}

func renderMygration(tpl *template.Template, id int, name string) (*bytes.Buffer, error) {
	buf := new(bytes.Buffer)
	err := tpl.Execute(buf, &tplVarForMygration{
		ID:   id,
		Name: name,
	})
	return buf, err
}

// GenerateMygration generates a migration file with the default template.
func GenerateMygration(mygrationsPath string, id int, name string) error {
	p := path.Join(mygrationsPath, "mygration.tpl")
	tplFile, err := ioutil.ReadFile(p)
	if err != nil {
		return err
	}

	tpl := template.Must(template.New("mygration.go").Parse(string(tplFile)))

	buf, err := renderMygration(tpl, id, name)
	if err != nil {
		return err
	}

	filePath := filepath.Join(mygrationsPath, fmt.Sprintf("%d_%s.go", id, name))
	err = ioutil.WriteFile(filePath, buf.Bytes(), 0644)
	if err != nil {
		return err
	}

	return nil
}

// GenerateMygrations will walk the mygration folder, generate the mygration.go file
// and register all migrations.
func GenerateMygrations(mygrationsPath string) error {
	mygrationFiles := findMygrationsInDir(mygrationsPath)
	sort.Strings(mygrationFiles)

	var tplMygrations []*tplMygration
	for _, p := range mygrationFiles {
		id, name, err := parseIDAndName(p)
		if err != nil {
			continue
		}

		tplMygrations = append(tplMygrations, &tplMygration{
			ID:   id,
			Name: name,
			Up:   fmt.Sprintf("Mygration_%d_%s_up", id, name),
			Down: fmt.Sprintf("Mygration_%d_%s_down", id, name),
		})
	}

	buf := new(bytes.Buffer)
	err := templateMygrationsGo.Execute(buf, &tplVarForMygrations{
		Time:       time.Now(),
		Mygrations: tplMygrations,
	})
	if err != nil {
		return err
	}

	err = ioutil.WriteFile(filepath.Join(mygrationsPath, "mygrations.go"), buf.Bytes(), 0644)
	if err != nil {
		return err
	}

	return nil
}
